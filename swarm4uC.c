#define kClutID 132					// Resource ID of color lookup table (clut)	// Constants#define kMaxBees 100				// Maximum number of Bees.#define kQueenMaxVelocity 12		// Maximum Queen velocity (in pixels per frame).#define kQueenMaxAcceleration 5		// Maximum Queen acceleration.#define kBeeMaxVelocity  11			// Maximum Bee velocity.#define kBeeMaxAcceleration  3		// Maximum Bee acceleration.#define kBorderWidth  50			// Queen won't go any nearer than this many pixels to the									// edge of the screen and the demo rectangle.								// Here we define some handy macros for accessing the 	// Swarm's position and velocity values. These macros work under the	// assumption that you have a valid handle variable named 'swarm', pointing	// to a storage struct as defined in "The Swarm.h".	// Position of Bee b at time t (where t is either 0 or 1).#define BX(t,b)  (*((*(swarm->beeX[t]))+(b)))#define BY(t,b)  (*((*(swarm->beeY[t]))+(b)))	// Current velocity of Bee b.#define BXV(b)	(*((*swarm->beeVelocityX)+(b)))#define BYV(b)	(*((*swarm->beeVelocityY)+(b)))	// Position of the Queen at time t (where t is either 0 or 1).#define QX(t)  (swarm->queenX[t])#define QY(t)  (swarm->queenY[t])	// Current velocity of the Queen.#define QXV	(swarm->queenVelocityX)#define QYV	(swarm->queenVelocityY)	// Some more handy macros.#define RAND(v) (RangedRdm(-(v)/2, (v)/2))		// Random integer around 0.  #define abs(x) (((x) > 0) ? (x) : -(x))			// Standard macro for 'abs'.#define setmin(x, min) if (x < min) min = x;	// Keep track of a minimum value.#define setmax(x, max) if (x > max) max = x;	// Keep track of a maxmimum value.// Now we come to the fun part: the actual implementations of the functions.// First: DoInitialize, which allocates our swarm data structure as defined// above, initializes the variables in that struct, and does a gazillion checks// for possible problems.DoInitialize (Handle *storage, GMParamBlockPtr params){    register TSwarmDataPtr swarm;	// The swarm, obviously.    register short b;				// Index for Bee loops.		// See DoDrawFrame for more info on how this variable is used to implement	// the delay.	swarm->startDrawing = LMGetTicks();				// Initial Queen position. The checks are sanity checks for the	// RangedRdm function which I'm leaving in because I don't	// trust RangedRdm at all.    QX(0) = swarm->monitorRect.left + RangedRdm(swarm->border, swarm->winW - swarm->border);    if (QX(0) < 10)	{		DoClose(*storage, (RgnHandle) nil, (GMParamBlockPtr) nil);		ErrorMsg("The Swarm:  Internal Error Ñ Initial Queen position: X coordinate is smaller than 10!");		return ModuleError;	}		QY(0) = swarm->monitorRect.top + RangedRdm(swarm->border, swarm->winH - swarm->border);    if (QY(0) < 10)	{		DoClose(*storage, (RgnHandle) nil, (GMParamBlockPtr) nil);		ErrorMsg("The Swarm:  Internal Error Ñ Initial Queen position: Y coordinate is smaller than 10!");		return ModuleError;	}    if (QX(0) < 10)	{		DoClose(*storage, (RgnHandle) nil, (GMParamBlockPtr) nil);		ErrorMsg("The Swarm:  Internal Error Ñ Initial Queen position: X coordinate is smaller than 10, after the demo check!");		return ModuleError;	}    if (QY(0) < 10)	{		DoClose(*storage, (RgnHandle) nil, (GMParamBlockPtr) nil);		ErrorMsg("The Swarm:  Internal Error Ñ Initial Queen position: Y coordinate is smaller then 10, after the demo check!");		return ModuleError;	}		// For the first frame, our line segment is just a point.    QX(1) = QX(0);    QY(1) = QY(0);    QXV = QYV = 0;    		// Ditto for the Bees, although (a) all Bees start from the same	// physical position as the Queen, and (b) all Bees have a different	// initial velocity. This gives a nice 'fountaining' effect on startup	// of the animation.    for (b = 0; b < kMaxBees; b++)    {        BX(0,b) = QX(0);        BX(1,b) = BX(0,b);        BY(0,b) = QY(0);        BY(1,b) = BY(0,b);        BXV(b) = RAND(7);        BYV(b) = RAND(7);    }}	// Finally we come to the meat of our module: the DoDrawFrame function.// Although there is a lot of code here, what actually happens is quite simple.// First, all the position and velocity variables are updated and checked for bouncing etc.// Then, we *erase* (in the offscreen world) the 'old' swarm by filling the swarm's//   bounding rectangle (which will vary from frame to frame!) with the background color.// Then, we draw the 'new' swarm.// Finally, we use the famous 'CopyBits' function to move the changed areas of the// offscreen world to the real screen world. And that's all.	// One more comment: a lot of the array accesses could have been optimized// to make the code run faster. Local variables could have been used to avoid// the indirect accesses caused by all those global handles and arrays.// The BlockMove function could have been called to update entire arrays in// one sweep.// However, all those accesses taken together still take up only a negligable fraction// of this function's total execution time, when compared to the cost of// doing the graphics. CopyBits is an expensive function, and for large numbers// of Bees the drawing of the line segments takes even more time.// This is why I have decided to refrain from optimizing. It doesn't matter very// much speedwise, and such optimizations would only obscure the underlying algorithm.DoDrawFrame (Handle storage, GMParamBlockPtr params){	        GWorldPtr currPort;		// The 'real' screen consists of two components.	GDHandle  currDev;		// which we'll save in these variables.			// The actual pixel maps of offscreen and real screen, respectively.	PixMapHandle offBase, realBase;	Rect unionRect;			// Distances from a Bee to the Queen.    short dx, dy, distance;					// Bee counter for loops.    register short b;		// storage was already locked in DoInitialize, so this is safe.    swarm = (TSwarmDataPtr) *storage;        nBees = swarm->nBees;	    	// Age the swarm bouding rectangle.    *oldRect = *swarmRect;    	// First, we do the Queen Stuff:	// Age the position arrays.     QX(1) = QX(0);    QY(1) = QY(0);    		// Accelerate.    QXV += RAND(swarm->maxQueenAcceleration);    QYV += RAND(swarm->maxQueenAcceleration);	// Speed limit checks.    if (QXV > swarm->maxQueenVelocity)        QXV = swarm->maxQueenVelocity;    else     	if (QXV < -swarm->maxQueenVelocity)        	QXV = -swarm->maxQueenVelocity;    if (QYV > swarm->maxQueenVelocity)        QYV = swarm->maxQueenVelocity;    else    	if (QYV < -swarm->maxQueenVelocity)        	QYV = -swarm->maxQueenVelocity;	// Fill new 'current' positions.    QX(0) = QX(1) + QXV;    QY(0) = QY(1) + QYV;	// Bounce Checks.	if ((QX(0) < monitorRect.left + border) || (QX(0) > monitorRect.left + winW - border - 1))    {		// These two statements (and all similar ones further on)		// cause a swarm element to 'bounce off' according to a		// "angle of entry is angle of exit" rule. It looks much more		// cryptic than it really is. Trust me.        QXV = -QXV;        QX(0) += QXV << 1;    }    if ((QY(0) < monitorRect.top + border) || (QY(0) > monitorRect.top + winH - border - 1))    {        QYV = -QYV;        QY(0) += QYV << 1;    }     		        	// Keep track of the minimal bouding rect of the swarm so far.    setmin(QX(0), xMin);    setmin(QY(0), yMin);	setmax(QX(0), xMax);    setmax(QY(0), yMax);	setmin(QX(1), xMin);    setmin(QY(1), yMin);	setmax(QX(1), xMax);    setmax(QY(1), yMax);       			// Now we get to the Bee stuff, which is basically	// the same, except that (a) Bees do *not* bounce off walls or	// demoRects, and (b) Bees will try to 'follow' the Queen.   		 	// First, don't ever let things settle down.     if (nBees > 0)          // Avoid later division by 0!    {        BXV(RangedRdm(0, nBees)) += RAND(3);        BYV(RangedRdm(0, nBees)) += RAND(3);    }	    for (b = 0; b < nBees; b++)    {		// Age the arrays.         BX(1, b) = BX(0, b);        BY(1, b) = BY(0, b);        		// Accelerate.        dx = QX(1) - BX(1, b);        dy = QY(1) - BY(1, b);        			// This calculation of the true distance from the dx/dy values		// is an approximation that allows us to keep everything in 		// integer math. Otherwise we'd have do square root operations...        distance = abs(dx) + abs(dy);         if (distance == 0)            distance = 1;        BXV(b) += (dx * swarm->maxBeeAcceleration) / distance;                 BYV(b) += (dy * swarm->maxBeeAcceleration) / distance;		// Speed limit checks.        if (BXV(b) > swarm->maxBeeVelocity)            BXV(b) = swarm->maxBeeVelocity;        else         	if (BXV(b) < -swarm->maxBeeVelocity)            	BXV(b) = -swarm->maxBeeVelocity;        if (BYV(b) > swarm->maxBeeVelocity)            BYV(b) = swarm->maxBeeVelocity;        else        	if (BYV(b) < -swarm->maxBeeVelocity)            	BYV(b) = -swarm->maxBeeVelocity;		// Fill new 'current' positions.        BX(0, b) = BX(1, b) + BXV(b);        BY(0, b) = BY(1, b) + BYV(b);        		// Keep track of the minimal bouding rect of the swarm so far.        setmin(BX(0,b), xMin);        setmax(BX(0,b), xMax);        setmin(BX(1,b), xMin);        setmax(BX(1,b), xMax);        setmin(BY(0,b), yMin);        setmax(BY(0,b), yMax);        setmin(BY(1,b), yMin);        setmax(BY(1,b), yMax);       }       		// swarmRect will now be set to the minimal bounding rectangle we've been maintaining,	// which we want to 'clip' by intersecting it with the screen rectangle,	// and which we finally need to combine with the *old* bounding rectangle,	// to give as a result the minimal bounding rectangle of the entire screen	// area that has been affected by this step of the animation.		    SetRect(swarmRect, xMin-1, yMin-1, xMax+1, yMax+1);    SectRect(&monitorRect, swarmRect, swarmRect);    UnionRect(oldRect, swarmRect, &unionRect);    	// Save the real screen world.	GetGWorld(&currPort, &currDev);		// Switch to the offscreen world.    SetGWorld (swarm->gMyOffG, nil);    		// Erase the old swarm bounding rectangle.	RGBBackColor(&swarm->backRGB);    EraseRect(oldRect);    	// Draw the new swarm, first Queen, then Bees.    RGBForeColor(&queenRGB);    LineFromTo(QX(0),QY(0), QX(1),QY(1));			RGBForeColor(&swarm->beeRGB);	// Draw the Bees.    for (b = 0; b < nBees; b++)        LineFromTo(BX(0, b),BY(0, b), BX(1, b),BY(1, b));			// Switch back to the real screen.    	SetGWorld(currPort, currDev);	   		   		// Retrieve actual pixel maps for both offscreen and real screen.	realBase = GetGWorldPixMap((GWorldPtr) currPort);	offBase  = GetGWorldPixMap(swarm->gMyOffG);	// These next two calls appear to make no sense, but	// are absolutely necessary for CopyBits to function	// correctly. See the Apple TechNote on this subject (or Inside Macintosh)    RGBBackColor(&whiteRGB);	RGBForeColor(&swarm->blackRGB);			   	// Blit the changed area from offscreen to realscreen.	CopyBits((BitMap *) (*offBase), (BitMap *) (*realBase), 			  &unionRect, &unionRect,			  srcCopy, nil);}